<html>
<body>
  <h1>Quadtree User</h1>
  
  <div>
    <label for="xInput">X:</label>
    <input type="number" id="xInput">
  </div>
  
  <div>
    <label for="yInput">Y:</label>
    <input type="number" id="yInput">
  </div>
  
  <button id="insertButton">Insert Node</button>
  
  <div>
    <label for="searchXInput">Search X:</label>
    <input type="number" id="searchXInput">
  </div>
  
  <div>
    <label for="searchYInput">Search Y:</label>
    <input type="number" id="searchYInput">
  </div>
  
  <button id="searchButton">Search Node</button>
  
  <div id="output"></div>
  
  <script>
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      
      distanceToOrigin() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
    }
    
    class Node {
      constructor(pos, data) {
        this.pos = pos;
        this.data = data;
      }
    }
    
    class Quad {
      constructor(topL, botR) {
        this.topLeft = topL;
        this.botRight = botR;
        this.n = null;
        this.topLeftTree = null;
        this.topRightTree = null;
        this.botLeftTree = null;
        this.botRightTree = null;
      }

      insert(node) {
        if (node === null) {
          return;
        }

        if (!this.inBoundary(node.pos)) {
          return;
        }

        if (Math.abs(this.topLeft.x - this.botRight.x) <= 1 && Math.abs(this.topLeft.y - this.botRight.y) <= 1) {
          if (this.n === null) {
            this.n = node;
          }
          return;
        }

        if ((this.topLeft.x + this.botRight.x) / 2 >= node.pos.x) {
          if ((this.topLeft.y + this.botRight.y) / 2 >= node.pos.y) {
            if (this.topLeftTree === null) {
              this.topLeftTree = new Quad(this.topLeft, new Point((this.topLeft.x + this.botRight.x) / 2, (this.topLeft.y + this.botRight.y) / 2));
            }
            this.topLeftTree.insert(node);
          }
          else {
            if (this.botLeftTree === null) {
              this.botLeftTree = new Quad(new Point(this.topLeft.x, (this.topLeft.y + this.botRight.y) / 2), new Point((this.topLeft.x + this.botRight.x) / 2, this.botRight.y));
            }
            this.botLeftTree.insert(node);
          }
        } else {
          if ((this.topLeft.y + this.botRight.y) / 2 >= node.pos.y) {
            if (this.topRightTree === null) {
              this.topRightTree = new Quad(new Point((this.topLeft.x + this.botRight.x) / 2, this.topLeft.y), new Point(this.botRight.x, (this.topLeft.y + this.botRight.y) / 2));
            }
            this.topRightTree.insert(node);
          }
          else {
            if (this.botRightTree === null) {
              this.botRightTree = new Quad(new Point((this.topLeft.x + this.botRight.x) / 2, (this.topLeft.y + this.botRight.y) / 2), this.botRight);
            }
            this.botRightTree.insert(node);
          }
        }
      }

      search(p) {
        if (!this.inBoundary(p)) {
          return 0; // Return 0 if point is not found
        }
        if (this.n !== null) {
          return this.n;
        }

        if ((this.topLeft.x + this.botRight.x) / 2 >= p.x) {
          if ((this.topLeft.y + this.botRight.y) / 2 >= p.y) {
            if (this.topLeftTree === null) {
              return 0;
            }
            return this.topLeftTree.search(p);
          }
          else {
            if (this.botLeftTree === null) {
              return 0;
            }
            return this.botLeftTree.search(p);
          }
        } else {
          if ((this.topLeft.y + this.botRight.y) / 2 >= p.y) {
            if (this.topRightTree === null) {
              return 0;
            }
            return this.topRightTree.search(p);
          }
          else {
            if (this.botRightTree === null) {
              return 0;
            }
            return this.botRightTree.search(p);
          }
        }
      }
      inBoundary(p) {
        return p.x >= this.topLeft.x && p.x <= this.botRight.x && p.y >= this.topLeft.y && p.y <= this.botRight.y;
      }
    }
    document.getElementById("insertButton").addEventListener("click", function() {
      var x = parseInt(document.getElementById("xInput").value);
      var y = parseInt(document.getElementById("yInput").value);
      var node = new Node(new Point(x, y), null);
      center.insert(node);
      
      document.getElementById("output").textContent = "Node inserted successfully.";
      
      var nodesArray = getAllNodes(center);
      document.getElementById("output").textContent += "Nodes: " + JSON.stringify(nodesArray);
    });
    
    document.getElementById("searchButton").addEventListener("click", function() {
      var x = parseInt(document.getElementById("searchXInput").value);
      var y = parseInt(document.getElementById("searchYInput").value);
      var point = new Point(x, y);
      var result = center.search(point);
      if (result !== 0) {
        document.getElementById("output").textContent = "Node found: " + result.data + ", Distance from origin: " + point.distanceToOrigin();
      } else {
        document.getElementById("output").textContent = "Node not found.";
      }
    });
    const center = new Quad(new Point(0, 0), new Point(8, 8));
    const a = new Node(new Point(1, 1), 1);
    const b = new Node(new Point(2, 5), 2);
    const c = new Node(new Point(7, 6), 3);
    center.insert(a);
    center.insert(b);
    center.insert(c);
    console.log("Node a:", center.search(new Point(1, 1)).data);
    console.log("Node b:", center.search(new Point(2, 5)).data);
    console.log("Node c:", center.search(new Point(7, 6)).data);
    console.log("Non-existing node:", center.search(new Point(5, 5)));
    function getAllNodes(quad) {
      var nodes = [];
      
      if (quad.n !== null) {
        nodes.push(quad.n);
      }
      
      if (quad.topLeftTree !== null) {
        nodes = nodes.concat(getAllNodes(quad.topLeftTree));
      }
      
      if (quad.topRightTree !== null) {
        nodes = nodes.concat(getAllNodes(quad.topRightTree));
      }
      
      if (quad.botLeftTree !== null) {
        nodes = nodes.concat(getAllNodes(quad.botLeftTree));
      }
      
      if (quad.botRightTree !== null) {
        nodes = nodes.concat(getAllNodes(quad.botRightTree));
      }
      
      return nodes;
    }
  </script>
</html>
